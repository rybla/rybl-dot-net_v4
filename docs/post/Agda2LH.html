<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>rybl.net | /post/Agda2LH.html</title><link rel="stylesheet" href="/asset/style/common.css"/><link rel="stylesheet" href="/asset/style/util.css"/><link rel="stylesheet" href="/asset/style/Top.css"/><link rel="stylesheet" href="/asset/style/Tag.css"/><link rel="stylesheet" href="/asset/style/ParsedDate.css"/><link rel="stylesheet" href="/asset/style/Header.css"/><link rel="stylesheet" href="/asset/style/Footer.css"/><link rel="stylesheet" href="/asset/style/Raindrops.css"/><link rel="stylesheet" href="/asset/style/Markdown.css"/><link rel="stylesheet" href="/asset/style/Post.css"/><script src="/asset/script/Post.js"></script></head><body><div id="raindrop_container"><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div><div class="raindrop"></div></div><header><div class="logo"><img src="/asset/image/profile.png"/></div><div class="name"><div class="website_name"><a href="/">rybl.net</a></div><div class="separator"></div><div class="resource_name"><div>/post/Agda2LH.html</div></div></div><div class="menu"><a href="/index.html" class="item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon lucide lucide-library-icon lucide-library"><path d="m16 6 4 14"></path><path d="M12 6v14"></path><path d="M8 8v12"></path><path d="M4 4v16"></path></svg></a><a href="/Tags.html" class="item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon lucide lucide-tag-icon lucide-tag"><path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"></path><circle cx="7.5" cy="7.5" r=".5" fill="currentColor"></circle></svg></a><a href="/About.html" class="item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon lucide lucide-info-icon lucide-info"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg></a><a href="https://github.com/rybla/" class="item"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon lucide lucide-github-icon lucide-github"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a></div></header><main><div class="content"><h1 id="agda2lh"><a href="http://localhost:3000/post/Agda2LH.html#agda2lh">agda2lh</a></h1>
<ol>
<li><a href="#Introduction%20to%20agda2hs" title="Introduction to agda2hs">Introduction to agda2hs</a></li>
<li><a href="#Problem_%20Agda%20is%20more%20expressive%20than%20Haskell" title="Problem: Agda is more expressive than Haskell">Problem: Agda is more expressive than Haskell</a></li>
<li><a href="#Solution_%20target%20LiquidHaskell%20with%20agda2lh" title="Solution: target LiquidHaskell with agda2lh">Solution: target LiquidHaskell with agda2lh</a></li>
<li><a href="#References" title="References">References</a></li>
</ol>
<h2 id="Introduction%20to%20agda2hs"><a href="http://localhost:3000/post/Agda2LH.html#Introduction%20to%20agda2hs">Introduction to agda2hs</a></h2>
<p>In the paper <em><a href="https://jesper.sikanda.be/files/reasonable-agda-is-correct-haskell.pdf" class="LinkWithIcon"><img src="/asset/icon/jesper.sikanda.be" class="icon"><span class="label">Reasonable Agda Is Correct Haskell: Writing Verified Haskell
using agda2hs</span></a></em>, the authors identify a reasonable correspondence
between a subset of Agda and Haskell within which they can perform a reasonable
translation from Agda to Haskell.</p>
<p>For example, consider the following Agda program:</p>
<pre><code class="language-agda">-- utilities

⊔ : ℕ → ℕ → ℕ
⊔-comm : ∀ m n → m ⊔ n ≡ n ⊔ m
{-# COMPILE AGDA2HS ⊔-comm irrelevant #-}

-- Tree

data Tree (A : Set) : (@0 _ : ℕ) -> Set where
  Leaf : Tree A 0
  Branch : A → ∀ nₗ nᵣ → Tree A nₗ → Tree A nᵣ → Tree A (nₗ ⊔ nᵣ)
{-# COMPILE AGDA2HS Tree #-}

-- mirror

mirror : ∀ {A} {n} → Tree A n → Tree A n
mirror Leaf = Leaf
mirror (Branch a nₗ nᵣ tₗ tᵣ) rewrite ⊔-comm nₗ nᵣ =
  Branch a nᵣ nₗ (mirror tᵣ) (mirror tₗ)
{-# COMPILE AGDA2HS mirror #-}
</code></pre>
<p><code>Tree</code> is indexed by its height, which is annotated by <code>@0</code> as
runtime-irrelevant. Without the height indexing, this Agda program could be
written in Haskell as the following, which is in fact what the <code>AGDA2HS</code>
annotations specify <code>agda2hs</code> to extract.</p>
<pre><code class="language-haskell">-- Tree

data Tree a where
  Leaf :: Tree
  Branch :: a -> Tree -> Tree -> Tree

-- mirror

mirror :: Tree a -> Tree a
mirror Leaf = Leaf
mirror (Branch a tl tr) = Branch a (mirror tr) (mirror tl)
</code></pre>
<p>Behaviorally, these programs are the same. But still something has been lost in
translation.</p>
<h2 id="Problem_%20Agda%20is%20more%20expressive%20than%20Haskell"><a href="http://localhost:3000/post/Agda2LH.html#Problem_%20Agda%20is%20more%20expressive%20than%20Haskell">Problem: Agda is more expressive than Haskell</a></h2>
<p>Since Haskell does not support full dependent typing, the Haskell program above
does not have the same statically-checked properties as the Agda program. In
particular, the Agda <code>mirror</code> preserves the height of the <code>Tree</code> it operates on,
since both the input and the output type are <code>Tree</code>s with height index <code>n</code>. The
Haskell <code>mirror</code> has no such statically-ensured property -- the Haskell <code>Tree</code>
is not height-indexed.</p>
<p>Of course, one could use some advanced Haskell type features to include a sort
of height-indexing into the Haskell <code>Tree</code> (perhaps something like <code>-XGADTs</code>,
<code>-XDataKinds</code>, <code>-XTypeFamilies</code>). But, these sorts of techniques are clunky,
hard to generalize, probably require some explicit witnesses, and, very
importantly, don't interoperate well with other Haskell code that are not also
using fancy GADTs with indexing.</p>
<p>In summary, what we are lacking is a Haskell target that maintains the static
checks of the original Agda code and is still easily interoperable with normal
Haskell code when desired.</p>
<h2 id="Solution_%20target%20LiquidHaskell%20with%20agda2lh"><a href="http://localhost:3000/post/Agda2LH.html#Solution_%20target%20LiquidHaskell%20with%20agda2lh">Solution: target LiquidHaskell with agda2lh</a></h2>
<p><em><a href="https://github.com/ucsd-progsys/liquidhaskell" class="LinkWithIcon"><img src="/asset/icon/github.com" class="icon"><span class="label">Liquid Haskell</span></a></em> is a plugin to Haskell that adds automatically-checked
refinement types to Haskell's type system. A <em>refinement type</em> is a basic
Haskell type that is <em>refined</em> by a boolean predicate over values of the type.
For example, the following function has a refined input type and a refined
output type.</p>
<pre><code class="language-haskell">{-@ mulOdds :: {x:Int | (x % 2) == 1} -> {y:Int | (x % 2) == 1}
            -> {z:Int | (z % 2) == 0} @-}
mulOdds :: Int -> Int -> Int
mulOdds x y = x * y
</code></pre>
<p>In this way, Liquid Haskell adds lightweight dependent types to Haskell, with
heavy (SMT-powered) automation for checking refinements (The proof that the
product of two odds is even is not totally trivial, and the SMT solver figured
it out!). Since Liquid Haskell can ensure dependent-types related properties
(such as indexing of datatypes) via typechecking then perhaps we can attempt to
encode the information discarded by <code>agda2hs</code> as Liquid Haskell refinements.</p>
<pre><code class="language-haskell">{-@ LIQUID "--reflection" @-}
{-@ LIQUID "--ple" @-}

-- utilities

{-@ by :: {x:a1 | b1} -> {y:a2 | b2} -> {x':a1 | (x == x') &#x26;&#x26; b1 &#x26;&#x26; b2} @-}

-- Nat

data Nat = Zero | Suc Nat deriving (Eq)

{-@ reflect max @-}
max :: Nat -> Nat -> N
max Zero n = n
max m Zero = m
max (Suc m) (Suc n) = Suc (max m n)

{-@ max_comm :: m:Nat -> n:Nat -> {max m n == max n m} @-}
max_comm :: Nat -> Nat -> ()
max_comm (Suc m) (Suc n) = max_comm m n
max_comm _ _ = ()

-- Tree

data Tree a = Leaf | Branch a (Tree a) (Tree a)

-- derived from indexing in definition of Agda `Tree`
{-@ reflect height @-}
height :: Tree a -> Nat
height Leaf = Zero
height (Branch _ tl tr) = max (height tl) (height tr)

-- mirror

-- preserves height of `Tree`
{-@ mirror :: t:Tree a -> {t':Tree a | height t == height t'} @-}
mirror :: Tree a -> Tree a
mirror Leaf = Leaf
mirror (Branch a tl tr) =
    Branch a (mirror tr) (mirror tl)
      `by` max_comm (height tl) (height tr)
</code></pre>
<p>This kind of translation required a few derivations:</p>
<ul>
<li>The Agda lemma <code>⊔-comm</code> was translated to the Liquid Haskell lemma <code>max_comm</code>,
which implicitly converted Agda's propositional equality <code>_≡_</code> into Liquid
Haskell's refinement-level decidable equality <code>(==)</code>. This translation
requires that Agda's <code>_≡_ {ℕ}</code> is decidable, and also the the user must
specify that <code>_≡_</code> is meant to be proof-irrelevant</li>
<li>The Agda datatype <code>Tree</code>'s height index is extracted to a reflected Liquid
Haskell function <code>height</code>. This derivation is performed by inspecting the
output index for each constructor of Agda's <code>Tree</code>.</li>
</ul>
<p>In the same style of <code>agda2hs</code>, an <code>agda2lh</code> could be annotated like so to
specify these derivations.</p>
<pre><code class="language-agda">-- utilities

-- decidable equality over ℕ
_==_ : ∀ (m n : ℕ) → Dec (m ≡ n)
zero == zero = yes refl
zero == suc n = no λ ()
suc m == zero = no λ ()
suc m == suc n with m == n
suc m == suc n    | yes m≡n = yes (cong suc m≡n)
suc m == suc n    | no ¬m≡n = no (λ { refl → ¬m≡n refl })
-- specify that `_==_` should be used as the instance of decidable equality
-- over `ℕ` for refinement-relevant extractions
{-# COMPILE AGDA2LH _==_ REFINEMENT-EQUALITY(ℕ) #-}

⊔ : ℕ → ℕ → ℕ
⊔-comm : ∀ m n → m ⊔ n ≡ n ⊔ m
-- specify that `⊔-comm` is proof-irrelevant but refinement-relevant; uses
-- `_==_` as the instance of decidable equality in the extracted refinement, as
-- per the previous annotation
{-# COMPILE AGDA2LH ⊔-comm REFINEMENT #-}

-- Tree

data Tree (A : Set) : (@0 height : ℕ) -> Set where
  Leaf : Tree A 0
  Branch : A → ∀ nₗ nᵣ → Tree A nₗ → Tree A nᵣ → Tree A (nₗ ⊔ nᵣ)
-- specify that `Tree`'s term-irrelevant parameter `height` should be extracted
-- as an index which is kept track of by extracted refinements.
{-# COMPILE AGDA2LH Tree REFINEMENT-INDEX(height) #-}

-- mirror

mirror : ∀ {A} {n} → Tree A n → Tree A n
mirror Leaf = Leaf
mirror (Branch a nₗ nᵣ tₗ tᵣ) rewrite ⊔-comm nₗ nᵣ =
  Branch a nᵣ nₗ (mirror tᵣ) (mirror tₗ)
-- no special annotations needed here; the enforcement of `mirror` preserving
-- height is derived from the previous annotation that specifies the `height`
-- of a tree to be refinement-relevant index
{-# COMPILE AGDA2LH mirror #-}
</code></pre>
<h2 id="References"><a href="http://localhost:3000/post/Agda2LH.html#References">References</a></h2>
<ul>
<li><a href="https://jesper.sikanda.be/files/reasonable-agda-is-correct-haskell.pdf" class="LinkWithIcon"><img src="/asset/icon/jesper.sikanda.be" class="icon"><span class="label">https://jesper.sikanda.be/files/reasonable-agda-is-correct-haskell.pdf</span></a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell" class="LinkWithIcon"><img src="/asset/icon/github.com" class="icon"><span class="label">GitHub - ucsd-progsys/liquidhaskell: Liquid Types For Haskell</span></a></li>
</ul></div></main><footer></footer></body></html>